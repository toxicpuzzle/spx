        -:    0:Source:spx_common.h
        -:    0:Graph:spx_exchange.gcno
        -:    0:Data:spx_exchange.gcda
        -:    0:Runs:1
        -:    1:#ifndef SPX_COMMON_H
        -:    2:#define SPX_COMMON_H
        -:    3:
        -:    4:// #define _POSIX_SOURCE
        -:    5:#define _DEFAULT_SOURCE
        -:    6:
        -:    7:#include <stdio.h>
        -:    8:#include <stdlib.h>
        -:    9:#include <string.h>
        -:   10:#include <signal.h>
        -:   11:#include <unistd.h>
        -:   12:#include <fcntl.h>
        -:   13:#include <sys/types.h>
        -:   14:#include <sys/stat.h>
        -:   15:#include <stdbool.h>
        -:   16:#include <errno.h>
        -:   17:#include <math.h>
        -:   18:// #include "data_types/dyn_array.h"
        -:   19:// #include "data_types/prio_queue.h"
        -:   20:// #include "data_types/linked_list.h"
        -:   21:#include <poll.h>
        -:   22:#include <sys/wait.h>
        -:   23:#include <ctype.h>
        -:   24:
        -:   25:#define FIFO_EXCHANGE "/tmp/spx_exchange_%d"
        -:   26:#define FIFO_TRADER "/tmp/spx_trader_%d"
        -:   27:#define FEE_PERCENTAGE 1
        -:   28:#define MAX_LINE 128
        -:   29:#define MAX_INT 999999
        -:   30:#define INDENT printf("\t");
        -:   31:
        -:   32://! Don't put function definition in header files since then you'll have to clean and compile every time 
        -:   33:
        -:   34:/**
        -:   35: * @brief Writes message to one end of pipe (excludes null byte at end of string)
        -:   36: * 
        -:   37: * @param fd_write fd of write end of pipe
        -:   38: * @param str message to be sent (terminate with null byte)
        -:   39: */
        4:   40:void fifo_write(int fd_write, char* str){
        -:   41:    // TODO: Investigate reason for spx_exchange quitting.
        4:   42:    struct pollfd p;
        4:   43:    p.fd = fd_write;
        4:   44:    p.events = POLLOUT;
        4:   45:    poll(&p, 1, 0);
        4:   46:    if (!(p.revents & POLLERR)){
        4:   47:        if (write(fd_write, str, strlen(str)) == -1){
    #####:   48:                perror("Write unsuccesful\n");
        -:   49:        }   
        -:   50:    }     
        4:   51:}
        -:   52:
        -:   53:// TODO: change this to write using different protocol
        -:   54:// void fifo_write(int fd_write, char* str){
        -:   55://     int len = strlen(str)+1;
        -:   56://     if (write(fd_write, &len, sizeof(int)) == -1){
        -:   57://         perror("Write unsuccesful\n");
        -:   58://     }
        -:   59://     if (write(fd_write, str, len) == -1){
        -:   60://         perror("Write unsuccesful\n");
        -:   61://     }
        -:   62:// }
        -:   63:
        -:   64:// void new_fifo_write(int fd_write, char* str){
        -:   65://     write(fd_write, str, strlen(str));
        -:   66:// }
        -:   67:
        -:   68:/**
        -:   69: * @brief  Readss from pipe for a single command until ';', '\0', or EOF (inclusive)
        -:   70: * 
        -:   71: * @param fd_read The file descriptor for the read end fo the pipe
        -:   72: * @param str A string buffer of size MAX_LINE to put the items from the fifo
        -:   73: * @return char* The command terminated by '\0' character.
        -:   74: */
        -:   75://! Sometimes the correct message is read, but sometimes it isn't read.
        -:   76:// Change protocol to send int first and then send message
        -:   77:// TODO: Make this eliminate alst char in message; -> Must write with ;!
        -:   78:// char* fifo_read(int fd_read){
        -:   79://     int msg_size = 0;
        -:   80://     read(fd_read, &msg_size, sizeof(int));
        -:   81://     char* str = calloc(msg_size, sizeof(char));
        -:   82://     read(fd_read, str, msg_size*sizeof(char));
        -:   83://     str[strlen(str)-1] = '\0';
        -:   84://     return str;
        -:   85:// }
        -:   86:
        -:   87:// TODO: Only read sizeof(msg) -> just use function that I wrote below.
        -:   88:// char* new_fifo_read(int fd_read){
        -:   89://     char* msg = calloc(MAX_LINE, sizeof(char));
        -:   90://     read(fd_read, msg, msg);
        -:   91:// }
        -:   92:
        -:   93:
        -:   94:
        1:   95:char* fifo_read(int fd_read){
        -:   96:    
        1:   97:    int size = 1;
        1:   98:    char* str = calloc(size, sizeof(char));
        1:   99:    char curr;
        -:  100:    
        -:  101:    while (true){
       24:  102:        if (read(fd_read, (void*) &curr, 1*sizeof(char)) <= 0 || curr == ';') break;
        -:  103:        // if (curr == EOF || curr == ';' || curr == '\0') break;
       23:  104:        memmove(str+size-1, &curr, 1);
       23:  105:        str = realloc(str, ++size);
        -:  106:    }
        -:  107:
        1:  108:    str[size-1] = '\0';    
        -:  109:    // printf("Amount read: %d, String is: %s\n", size-1, str);
        -:  110:  
        1:  111:    return str;
        -:  112:}
        -:  113:
        -:  114:
        -:  115:
        -:  116:
        -:  117:
        -:  118:// typedef struct fifo_msg fifo_msg;
        -:  119:
        -:  120:// //! Potential issue with one process relying on memory of another process's mem address
        -:  121://  //https://stackoverflow.com/questions/971802/how-can-i-put-a-pointer-on-the-pipe
        -:  122://   // Alternatively could used shared memory if you want to pass pointers.
        -:  123:// struct fifo_msg{
        -:  124://     int bytes;
        -:  125://     void* msg;
        -:  126:// };
        -:  127:
        -:  128:#endif
